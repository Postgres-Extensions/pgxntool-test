#!/usr/bin/env bats

# Test: pg_tle support
#
# Tests that pg_tle registration SQL generation works correctly:
# - Script exists and is executable
# - make pgtle creates pg_tle directory
# - Generates both version files by default
# - PGTLE_VERSION limits output to specific version
# - Version-specific schema parameter handling
# - All versions and upgrade paths included
# - Control file fields properly parsed
# - Works with and without requires field
# - Error handling for missing files
# - Make dependencies trigger rebuilds

load helpers

setup_file() {
  debug 1 ">>> ENTER setup_file: test-pgtle (PID=$$)"
  cd "$BATS_TEST_DIRNAME/.."
  export TOPDIR=$(pwd)
  load_test_env "pgtle"
  ensure_foundation "$TEST_DIR"
  debug 1 "<<< EXIT setup_file: test-pgtle (PID=$$)"
}

setup() {
  load_test_env "pgtle"
  cd "$TEST_REPO"
}

@test "pgtle: script exists and is executable" {
  [ -x "$TEST_REPO/pgxntool/pgtle-wrap.sh" ]
}

@test "pgtle: make pgtle creates pg_tle directory" {
  run make pgtle
  assert_success
  [ -d "pg_tle" ]
}

@test "pgtle: generates both version files by default" {
  # Files already generated by previous test
  [ -f "pg_tle/1.0.0-1.5.0/pgxntool-test.sql" ]
  [ -f "pg_tle/1.5.0+/pgxntool-test.sql" ]
}

@test "pgtle: PGTLE_VERSION limits output to specific version" {
  make clean
  rm -rf pg_tle/
  make pgtle PGTLE_VERSION=1.5.0+
  [ -f "pg_tle/1.5.0+/pgxntool-test.sql" ]
  [ ! -f "pg_tle/1.0.0-1.5.0/pgxntool-test.sql" ]
}

@test "pgtle: 1.0.0-1.5.0 file does not have schema parameter" {
  # Test 4 cleaned, so regenerate all files
  make pgtle
  # Verify install_extension calls do NOT have schema parameter
  # Count install_extension calls
  local count=$(grep -c "pgtle.install_extension" pg_tle/1.0.0-1.5.0/pgxntool-test.sql || echo "0")
  [ "$count" -gt 0 ]
  # Verify no schema parameter (should end with NULL or ARRAY[...] before closing paren)
  ! grep -q "schema parameter" pg_tle/1.0.0-1.5.0/pgxntool-test.sql
}

@test "pgtle: 1.5.0+ file has schema parameter" {
  # File already generated by previous test
  # Verify install_extension calls DO have schema parameter
  grep -q "schema parameter" pg_tle/1.5.0+/pgxntool-test.sql
}

@test "pgtle: delimiter not present in source SQL files" {
  ! grep -r '$_pgtle_wrap_delimiter_$' sql/ || true
}

@test "pgtle: all versions included in output file" {
  # Template has both 0.1.0 and 0.1.1 version files committed
  # File already generated by previous test
  # Should have at least 2 versions (0.1.0 and 0.1.1)
  local count=$(grep -c "pgtle.install_extension\|pgtle.install_extension_version_sql" pg_tle/1.5.0+/pgxntool-test.sql || echo "0")
  [ "$count" -ge 2 ]
}

@test "pgtle: upgrade paths included in output" {
  # File already generated by previous test
  grep -q "pgtle.install_update_path" pg_tle/1.5.0+/pgxntool-test.sql
}

@test "pgtle: control file comment becomes description" {
  # File already generated by previous test
  local comment=$(grep "^comment" pgxntool-test.control | sed "s/comment = '\(.*\)'/\1/" | sed "s/comment = \"\(.*\)\"/\1/")
  grep -qF "$comment" pg_tle/1.5.0+/pgxntool-test.sql
}

@test "pgtle: works without requires field" {
  # Remove requires if present
  if grep -q "^requires" pgxntool-test.control; then
    sed -i.bak '/^requires/d' pgxntool-test.control
    rm -f pgxntool-test.control.bak
  fi
  
  # Makefile should detect control file change and rebuild automatically
  make pgtle
  # Should generate successfully without requires
  [ -f "pg_tle/1.5.0+/pgxntool-test.sql" ]
  # Should use NULL instead of ARRAY when requires is missing
  grep -q "NULL" pg_tle/1.5.0+/pgxntool-test.sql
  ! grep -q "ARRAY\[" pg_tle/1.5.0+/pgxntool-test.sql || true
}

@test "pgtle: requires field becomes ARRAY when present" {
  # Ensure requires field is present (test 11 may have removed it)
  if ! grep -q "^requires" pgxntool-test.control; then
    echo "requires = 'plpgsql'" >> pgxntool-test.control
  fi
  
  # Verify control file is in Makefile dependencies
  # Use make print-VARIABLE to debug Makefile variable values
  run make print-PGXNTOOL_CONTROL_FILES
  assert_success
  assert_contains "pgxntool-test.control"
  
  # Sleep and touch to ensure make detects the control file change
  # Why sleeps are needed:
  # 1. Make uses file modification timestamps to determine if targets need rebuilding
  # 2. Filesystem timestamp granularity can be 1-2 seconds on some systems
  # 3. Test 11 just generated the output file, so we need to ensure enough time has passed
  # 4. We sleep 2 seconds first, then touch the control file, then sleep 1 more second
  #    to ensure the control file timestamp is definitely newer than the output file
  sleep 2
  touch pgxntool-test.control
  sleep 1
  
  # Makefile should detect control file change and rebuild automatically
  make pgtle
  grep -q "ARRAY\[" pg_tle/1.5.0+/pgxntool-test.sql
}

@test "pgtle: set_default_version included" {
  # File already generated by previous test
  grep -q "pgtle.set_default_version" pg_tle/1.5.0+/pgxntool-test.sql
}

@test "pgtle: BEGIN/COMMIT transaction wrapper" {
  # File already generated by previous test
  grep -q "^BEGIN;" pg_tle/1.5.0+/pgxntool-test.sql
  grep -q "^COMMIT;" pg_tle/1.5.0+/pgxntool-test.sql
}

@test "pgtle: make clean removes pg_tle directory" {
  make pgtle
  [ -d "pg_tle" ]
  make clean
  [ ! -d "pg_tle" ]
}

@test "pgtle: control file change triggers rebuild" {
  make pgtle
  local mtime1=$(stat -f %m pg_tle/1.5.0+/pgxntool-test.sql 2>/dev/null || stat -c %Y pg_tle/1.5.0+/pgxntool-test.sql)
  sleep 1
  touch pgxntool-test.control
  make pgtle
  local mtime2=$(stat -f %m pg_tle/1.5.0+/pgxntool-test.sql 2>/dev/null || stat -c %Y pg_tle/1.5.0+/pgxntool-test.sql)
  [ "$mtime2" -gt "$mtime1" ]
}

@test "pgtle: SQL file change triggers rebuild" {
  make pgtle
  local mtime1=$(stat -f %m pg_tle/1.5.0+/pgxntool-test.sql 2>/dev/null || stat -c %Y pg_tle/1.5.0+/pgxntool-test.sql)
  sleep 1
  touch sql/pgxntool-test--0.1.0.sql
  make pgtle
  local mtime2=$(stat -f %m pg_tle/1.5.0+/pgxntool-test.sql 2>/dev/null || stat -c %Y pg_tle/1.5.0+/pgxntool-test.sql)
  [ "$mtime2" -gt "$mtime1" ]
}

@test "pgtle: error on missing control file" {
  run "$TEST_REPO/pgxntool/pgtle-wrap.sh" --extension nonexistent --pgtle-version 1.5.0+
  assert_failure
  assert_contains "Control file not found"
}

@test "pgtle: error on no versioned SQL files" {
  # Create a temporary extension with no SQL files
  echo "default_version = '1.0'" > empty.control
  run "$TEST_REPO/pgxntool/pgtle-wrap.sh" --extension empty --pgtle-version 1.5.0+
  assert_failure
  assert_contains "No versioned SQL files found"
  rm -f empty.control
}

@test "pgtle: warning on module_pathname in control" {
  # Create a C extension control file
  echo "comment = 'C extension'" > cext.control
  echo "default_version = '1.0'" >> cext.control
  echo "module_pathname = '\$libdir/cext'" >> cext.control
  echo "SELECT 1;" > sql/cext--1.0.sql

  run "$TEST_REPO/pgxntool/pgtle-wrap.sh" --extension cext --pgtle-version 1.5.0+
  # Should succeed but warn
  assert_success
  assert_contains "WARNING.*module_pathname"
  assert_contains "C code"
  
  # Cleanup
  rm -f cext.control sql/cext--1.0.sql
}

